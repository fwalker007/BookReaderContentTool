{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.ImageElement = exports.setImageLoaderHook = void 0;\n\nvar react_1 = __importDefault(require(\"react\")),\n    mobx_react_lite_1 = require(\"mobx-react-lite\"),\n    mobx_1 = require(\"mobx\"),\n    react_konva_1 = require(\"react-konva\"),\n    use_image_1 = __importDefault(require(\"use-image\")),\n    konva_1 = __importDefault(require(\"konva\")),\n    react_konva_utils_1 = require(\"react-konva-utils\"),\n    highlighter_1 = require(\"./highlighter\"),\n    loader_1 = require(\"../utils/loader\"),\n    apply_filters_1 = require(\"./apply-filters\"),\n    use_fadein_1 = require(\"./use-fadein\"),\n    useFlip = function useFlip(e, t) {\n  return react_1.default.useMemo(function () {\n    var r,\n        a,\n        o = e.flipX,\n        i = e.flipY,\n        n = \"svg\" === e.type || e.src.indexOf(\"data:image/svg+xml\") >= 0 || e.src.indexOf(\".svg\") >= 0;\n    if (!o && !i && !n) return t;\n    if (!t) return null;\n    var c = document.createElement(\"canvas\"),\n        l = 1;\n    \"svg\" === e.type && (l = Math.max(e.width / t.width, e.height / t.height)), c.width = t.width * l || 1, c.height = t.height * l || 1;\n    var d = o ? -c.width : 0,\n        h = i ? -c.height : 0;\n    return null === (r = c.getContext(\"2d\")) || void 0 === r || r.scale(o ? -1 : 1, i ? -1 : 1), null === (a = c.getContext(\"2d\")) || void 0 === a || a.drawImage(t, d, h, c.width, c.height), c;\n  }, [e.flipX, e.flipY, t, e.width, e.height]);\n},\n    usePlaceholder = function usePlaceholder(e) {\n  var t = e.width,\n      r = e.height,\n      a = e.image,\n      o = e.status,\n      i = react_1.default.useMemo(function () {\n    return a ? null : document.createElement(\"canvas\");\n  }, [a]);\n  return react_1.default.useMemo(function () {\n    if (!i) return a;\n    i.width = t, i.height = r;\n    var e = i.getContext(\"2d\");\n    if (!e) return a;\n    var n = \"failed\" === o ? \"rgba(223, 102, 102, 0.8)\" : \"rgba(124, 173, 212, 0.8)\",\n        c = \"failed\" === o ? \"Can not load the image...\" : \"Loading....\";\n    e.fillStyle = n, e.fillRect(0, 0, t, r), e.textAlign = \"center\", e.textBaseline = \"middle\";\n    var l = Math.min(30, t / c.length);\n    return e.font = l + \"px Arial\", e.fillStyle = \"white\", e.fillText(c, t / 2, r / 2), i;\n  }, [t, r, a, o, i]);\n},\n    LoadingPlaceholder = mobx_react_lite_1.observer(function (e) {\n  var t = e.element,\n      r = Math.min(30, t.width / 4, t.height / 4),\n      a = react_1.default.useRef(null);\n  return react_1.default.useEffect(function () {\n    var e = a.current;\n\n    if (e) {\n      var t = new konva_1.default.Animation(function (t) {\n        e.rotate(((null == t ? void 0 : t.timeDiff) || 0) / 2);\n      }, e.getLayer());\n      return t.start(), function () {\n        t.stop();\n      };\n    }\n  }), react_1.default.createElement(react_konva_1.Group, {\n    x: t.x,\n    y: t.y,\n    rotation: t.rotation,\n    listening: !1,\n    opacity: t.opacity\n  }, react_1.default.createElement(react_konva_1.Rect, {\n    width: t.width,\n    height: t.height,\n    fill: \"rgba(124, 173, 212, 0.8)\"\n  }), react_1.default.createElement(react_konva_1.Arc, {\n    ref: a,\n    x: t.width / 2,\n    y: t.height / 2,\n    fill: \"white\",\n    outerRadius: r,\n    innerRadius: Math.max(1, r - 5),\n    angle: 270\n  }));\n}),\n    useImageHook = use_image_1.default,\n    setImageLoaderHook = function setImageLoaderHook(e) {\n  useImageHook = e;\n};\n\nexports.setImageLoaderHook = setImageLoaderHook, exports.ImageElement = mobx_react_lite_1.observer(function (e) {\n  var t = e.element,\n      r = e.store,\n      a = react_1.default.useState(!1),\n      o = a[0],\n      i = a[1],\n      n = react_1.default.useRef(null),\n      c = react_1.default.useRef(null),\n      l = react_1.default.useState(!1),\n      d = l[0],\n      h = l[1],\n      u = r.selectedElements.indexOf(t) >= 0,\n      g = useImageHook(t.__finalSrc || t.src, \"Anonymous\"),\n      f = g[0],\n      s = g[1];\n  react_1.default.useEffect(function () {\n    \"loading\" === s ? loader_1.incrementLoader() : loader_1.decrementLoader();\n  }, [s]);\n\n  var _ = react_1.default.useState(\"loading\"),\n      p = _[0],\n      m = _[1];\n\n  react_1.default.useEffect(function () {\n    m(t.__isLoaded ? s : \"loading\");\n  }, [t.__isLoaded, s]), react_1.default.useEffect(function () {\n    \"svg\" === t.type && (\"loading\" === p ? loader_1.incrementLoader() : loader_1.decrementLoader());\n  }, [p]);\n  var v = react_1.default.useRef();\n  react_1.default.useEffect(function () {\n    v.current = f || v.current;\n  }, [f]);\n  var y = usePlaceholder({\n    width: t.width || 1,\n    height: t.height || 1,\n    image: f,\n    status: s\n  }),\n      x = \"failed\" !== s || \"failed\" !== s && \"svg\" === t.type,\n      b = useFlip(t, f || x && v.current) || y;\n  react_1.default.useEffect(function () {\n    var e;\n    o ? null === (e = n.current) || void 0 === e || e.clearCache() : apply_filters_1.applyFilter(n.current, t);\n  }, [o]), react_1.default.useEffect(function () {\n    apply_filters_1.applyFilter(n.current, t);\n  }, [t.shadowEnabled, t.shadowBlur]);\n  var w = t.cropX,\n      E = t.cropY,\n      M = t.cropWidth,\n      k = t.cropHeight;\n  \"loaded\" !== s && (w = E = 0, M = k = 1);\n  var X,\n      Y,\n      H = b.width * M,\n      S = b.height * k,\n      L = t.width / t.height,\n      W = H / S,\n      R = \"svg\" === t.type;\n  R ? (X = H, Y = S) : L >= W ? (X = H, Y = H / L) : (X = S * L, Y = S), react_1.default.useLayoutEffect(function () {\n    if (!o) return apply_filters_1.applyFilter(n.current, t), mobx_1.autorun(function () {\n      apply_filters_1.applyFilter(n.current, t);\n    }, {\n      delay: 100\n    });\n  }, [b, o, M, k]), use_fadein_1.useFadeIn(n);\n  var T = Math.max(t.width / X, t.height / Y);\n  react_1.default.useEffect(function () {\n    var e;\n\n    if (t._cropModeEnabled) {\n      var r = null === (e = n.current) || void 0 === e ? void 0 : e.getStage();\n      return document.body.addEventListener(\"click\", o), document.body.addEventListener(\"touchstart\", o), null == r || r.on(\"click\", a), null == r || r.on(\"touchstart\", a), function () {\n        document.body.removeEventListener(\"click\", o), document.body.removeEventListener(\"touchstart\", o), null == r || r.off(\"click\", a), null == r || r.off(\"click\", a);\n      };\n    }\n\n    function a(e) {\n      t._cropModeEnabled && e.target !== c.current && t.toggleCropMode(!1);\n    }\n\n    function o(e) {\n      t._cropModeEnabled && \"CANVAS\" !== e.target.nodeName && t.toggleCropMode(!1);\n    }\n  }, [t._cropModeEnabled]);\n  var I = react_1.default.useRef(null),\n      A = react_1.default.useRef(null),\n      C = react_1.default.useRef(null);\n  react_1.default.useLayoutEffect(function () {\n    t._cropModeEnabled && (A.current.nodes([I.current]), C.current.nodes([c.current]));\n  }, [t._cropModeEnabled]);\n\n  var D = function D(e) {\n    Math.round(e.target.x()) > 0 && (e.target.x(0), e.target.scaleX(1)), Math.round(e.target.y()) > 0 && (e.target.y(0), e.target.scaleY(1));\n    var r = e.target.width() * e.target.scaleX(),\n        a = e.target.height() * e.target.scaleY(),\n        o = Math.min(1, X / r),\n        i = Math.min(1, Y / a),\n        n = 1 - o,\n        c = Math.min(n, Math.max(0, Math.round(-e.target.x()) / r)),\n        l = 1 - i,\n        d = Math.min(l, Math.max(0, Math.round(-e.target.y()) / a));\n    e.target.setAttrs({\n      x: -c * b.width,\n      y: -d * b.height,\n      scaleX: 1,\n      scaleY: 1\n    }), t.set({\n      cropX: c,\n      cropY: d,\n      cropWidth: o,\n      cropHeight: i\n    });\n  },\n      q = function q() {\n    \"svg\" !== t.type && (t.locked || setTimeout(function () {\n      t.toggleCropMode(!0);\n    }));\n  },\n      F = \"svg\" === t.type && v.current,\n      P = \"loading\" === s && !F,\n      B = react_1.default.useRef({\n    cropX: 0,\n    cropY: 0,\n    cropWidth: 0,\n    cropHeight: 0\n  });\n\n  return react_1.default.createElement(react_1.default.Fragment, null, P && react_1.default.createElement(LoadingPlaceholder, {\n    element: t\n  }), react_1.default.createElement(react_konva_1.Image, {\n    ref: n,\n    name: \"element\",\n    image: b,\n    x: t.x,\n    y: t.y,\n    width: t.width || 1,\n    height: t.height || 1,\n    rotation: t.rotation,\n    opacity: P ? 0 : t.opacity,\n    shadowEnabled: t.shadowEnabled,\n    shadowBlur: t.shadowBlur,\n    cropX: b.width * w,\n    cropY: b.height * E,\n    cropWidth: X,\n    cropHeight: Y,\n    draggable: !t.locked,\n    onMouseEnter: function onMouseEnter() {\n      h(!0);\n    },\n    onMouseLeave: function onMouseLeave() {\n      h(!1);\n    },\n    onDragStart: function onDragStart() {\n      r.history.startTransaction();\n    },\n    onDragMove: function onDragMove(e) {\n      t.set({\n        x: e.target.x(),\n        y: e.target.y()\n      });\n    },\n    onDragEnd: function onDragEnd(e) {\n      t.set({\n        x: e.target.x(),\n        y: e.target.y()\n      }), r.history.endTransaction();\n    },\n    id: t.id,\n    onDblClick: q,\n    onDblTap: q,\n    onTransformStart: function onTransformStart() {\n      i(!0), r.history.startTransaction(), B.current = {\n        cropX: t.cropX,\n        cropY: t.cropY,\n        cropWidth: t.cropWidth,\n        cropHeight: t.cropHeight\n      };\n    },\n    onTransform: function onTransform(e) {\n      var r,\n          a = e.currentTarget,\n          o = Math.abs(a.scaleX() - 1) < 1e-7 ? 1 : a.scaleX(),\n          i = Math.abs(a.scaleY() - 1) < 1e-7 ? 1 : a.scaleY();\n      a.scaleX(1), a.scaleY(1);\n      var n = null === (r = e.target.getStage()) || void 0 === r ? void 0 : r.findOne(\"Transformer\"),\n          c = 1 - X / b.width,\n          l = Math.min(c, Math.max(0, t.cropX)),\n          d = 1 - Y / b.height,\n          h = Math.min(d, Math.max(0, t.cropY)),\n          u = n.getActiveAnchor(),\n          g = !(u.indexOf(\"middle\") >= 0 || u.indexOf(\"center\") >= 0),\n          f = !g && o < 1 && B.current.cropHeight > Y / b.height,\n          s = g ? t.cropWidth : t.cropWidth * o;\n      f && (s = t.cropWidth);\n\n      var _ = !g && i < 1 && B.current.cropWidth > X / b.width,\n          p = g ? t.cropHeight : t.cropHeight * i;\n\n      _ && (p = t.cropHeight), R && (s = t.cropWidth, p = t.cropHeight), t.set({\n        cropX: l,\n        cropY: h,\n        x: a.x(),\n        y: a.y(),\n        width: a.width() * o,\n        height: a.height() * i,\n        rotation: e.target.rotation(),\n        cropWidth: Math.min(s, 1 - l),\n        cropHeight: Math.min(p, 1 - h)\n      });\n    },\n    onTransformEnd: function onTransformEnd(e) {\n      var a = e.currentTarget;\n      t.set({\n        width: a.width(),\n        height: a.height(),\n        x: a.x(),\n        y: a.y(),\n        rotation: e.target.rotation(),\n        cropWidth: X / b.width,\n        cropHeight: Y / b.height\n      }), i(!1), r.history.endTransaction();\n    }\n  }), react_1.default.createElement(react_konva_1.Rect, {\n    x: t.x,\n    y: t.y,\n    width: t.width - t.borderSize,\n    height: t.height - t.borderSize,\n    offsetX: -t.borderSize / 2,\n    offsetY: -t.borderSize / 2,\n    stroke: t.borderColor,\n    strokeWidth: t.borderSize,\n    listening: !1,\n    visible: !!t.borderSize,\n    rotation: t.rotation\n  }), t._cropModeEnabled && react_1.default.createElement(react_konva_utils_1.Portal, {\n    selector: \".page-abs-container\",\n    enabled: !0\n  }, react_1.default.createElement(react_konva_1.Rect, {\n    x: -1500,\n    y: -1500,\n    width: 4500,\n    height: 4500,\n    fill: \"rgba(0,0,0,0.3)\"\n  }), react_1.default.createElement(react_konva_1.Image, {\n    listening: !1,\n    image: b,\n    x: t.x,\n    y: t.y,\n    width: t.width,\n    height: t.height,\n    rotation: t.rotation,\n    shadowEnabled: t.shadowEnabled,\n    shadowBlur: t.shadowBlur,\n    cropX: b.width * w,\n    cropY: b.height * E,\n    cropWidth: X,\n    cropHeight: Y\n  }), react_1.default.createElement(react_konva_1.Group, {\n    x: t.x,\n    y: t.y,\n    rotation: t.rotation,\n    scaleX: T,\n    scaleY: T\n  }, react_1.default.createElement(react_konva_1.Image, {\n    image: b,\n    ref: c,\n    opacity: .4,\n    draggable: !0,\n    x: -t.cropX * b.width,\n    y: -t.cropY * b.height,\n    onDragMove: D,\n    onTransform: D\n  }), react_1.default.createElement(react_konva_1.Transformer, {\n    ref: C,\n    anchorSize: 20,\n    enabledAnchors: [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"],\n    boundBoxFunc: function boundBoxFunc(e, t) {\n      return t.width < 5 || t.height < 5 ? e : t;\n    },\n    rotateEnabled: !1,\n    borderEnabled: !1,\n    anchorCornerRadius: 10,\n    anchorStrokeWidth: 2,\n    borderStrokeWidth: 2\n  }), react_1.default.createElement(react_konva_1.Rect, {\n    width: X,\n    height: Y,\n    ref: I,\n    listening: !1,\n    onTransform: function onTransform(e) {\n      e.target.x() < -t.cropX * b.width - 1e-9 && (e.target.x(-t.cropX * b.width), e.target.scaleX(1)), e.target.y() < -t.cropY * b.height - 1e-9 && (e.target.y(-t.cropY * b.height), e.target.scaleY(1));\n      var r = Math.min(1, Math.max(0, t.cropX + e.target.x() / b.width)),\n          a = Math.min(1, Math.max(0, e.target.y() / b.height + t.cropY)),\n          o = e.target.width() * e.target.scaleX(),\n          i = e.target.height() * e.target.scaleY(),\n          n = Math.min(1 - r, o / b.width),\n          c = Math.min(1 - a, i / b.height),\n          l = e.target.getAbsolutePosition(e.target.getParent().getParent());\n      e.target.scale({\n        x: 1,\n        y: 1\n      }), e.target.position({\n        x: 0,\n        y: 0\n      }), t.set({\n        x: l.x,\n        y: l.y,\n        cropX: r,\n        cropY: a,\n        cropWidth: n,\n        cropHeight: c,\n        width: Math.min(o * T, b.width * (1 - r) * T),\n        height: Math.min(i * T, b.height * (1 - a) * T)\n      });\n    }\n  }), react_1.default.createElement(react_konva_1.Transformer, {\n    ref: A,\n    enabledAnchors: [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"],\n    boundBoxFunc: function boundBoxFunc(e, t) {\n      return t.width < 5 || t.height < 5 ? e : t;\n    },\n    keepRatio: !1,\n    rotateEnabled: !1,\n    anchorFill: \"rgb(240, 240, 240)\",\n    anchorStrokeWidth: 2,\n    borderStrokeWidth: 2\n  }))), !u && d && react_1.default.createElement(highlighter_1.Highlighter, {\n    element: t\n  }));\n});","map":null,"metadata":{},"sourceType":"script"}