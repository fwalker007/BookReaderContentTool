{"ast":null,"code":"import _classCallCheck from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Util } from './Util.js';\nimport { Container } from './Container.js';\nimport { Node } from './Node.js';\nimport { Factory } from './Factory.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { getBooleanValidator } from './Validators.js';\nimport { shapes } from './Shape.js';\nimport { _registerNode } from './Global.js';\nvar HASH = '#',\n    BEFORE_DRAW = 'beforeDraw',\n    DRAW = 'draw',\n    INTERSECTION_OFFSETS = [{\n  x: 0,\n  y: 0\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}, {\n  x: 1,\n  y: 1\n}, {\n  x: -1,\n  y: 1\n}],\n    INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\nexport var Layer = /*#__PURE__*/function (_Container) {\n  _inherits(Layer, _Container);\n\n  var _super = _createSuper(Layer);\n\n  function Layer(config) {\n    var _this;\n\n    _classCallCheck(this, Layer);\n\n    _this = _super.call(this, config);\n    _this.canvas = new SceneCanvas();\n    _this.hitCanvas = new HitCanvas({\n      pixelRatio: 1\n    });\n    _this._waitingForDraw = false;\n\n    _this.on('visibleChange.konva', _this._checkVisibility);\n\n    _this._checkVisibility();\n\n    _this.on('imageSmoothingEnabledChange.konva', _this._setSmoothEnabled);\n\n    _this._setSmoothEnabled();\n\n    return _this;\n  }\n\n  _createClass(Layer, [{\n    key: \"createPNGStream\",\n    value: function createPNGStream() {\n      var c = this.canvas._canvas;\n      return c.createPNGStream();\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"getNativeCanvasElement\",\n    value: function getNativeCanvasElement() {\n      return this.canvas._canvas;\n    }\n  }, {\n    key: \"getHitCanvas\",\n    value: function getHitCanvas() {\n      return this.hitCanvas;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.getCanvas().getContext();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(bounds) {\n      this.getContext().clear(bounds);\n      this.getHitCanvas().getContext().clear(bounds);\n      return this;\n    }\n  }, {\n    key: \"setZIndex\",\n    value: function setZIndex(index) {\n      _get(_getPrototypeOf(Layer.prototype), \"setZIndex\", this).call(this, index);\n\n      var stage = this.getStage();\n\n      if (stage && stage.content) {\n        stage.content.removeChild(this.getNativeCanvasElement());\n\n        if (index < stage.children.length - 1) {\n          stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);\n        } else {\n          stage.content.appendChild(this.getNativeCanvasElement());\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"moveToTop\",\n    value: function moveToTop() {\n      Node.prototype.moveToTop.call(this);\n      var stage = this.getStage();\n\n      if (stage && stage.content) {\n        stage.content.removeChild(this.getNativeCanvasElement());\n        stage.content.appendChild(this.getNativeCanvasElement());\n      }\n\n      return true;\n    }\n  }, {\n    key: \"moveUp\",\n    value: function moveUp() {\n      var moved = Node.prototype.moveUp.call(this);\n\n      if (!moved) {\n        return false;\n      }\n\n      var stage = this.getStage();\n\n      if (!stage || !stage.content) {\n        return false;\n      }\n\n      stage.content.removeChild(this.getNativeCanvasElement());\n\n      if (this.index < stage.children.length - 1) {\n        stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);\n      } else {\n        stage.content.appendChild(this.getNativeCanvasElement());\n      }\n\n      return true;\n    }\n  }, {\n    key: \"moveDown\",\n    value: function moveDown() {\n      if (Node.prototype.moveDown.call(this)) {\n        var stage = this.getStage();\n\n        if (stage) {\n          var children = stage.children;\n\n          if (stage.content) {\n            stage.content.removeChild(this.getNativeCanvasElement());\n            stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"moveToBottom\",\n    value: function moveToBottom() {\n      if (Node.prototype.moveToBottom.call(this)) {\n        var stage = this.getStage();\n\n        if (stage) {\n          var children = stage.children;\n\n          if (stage.content) {\n            stage.content.removeChild(this.getNativeCanvasElement());\n            stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getLayer\",\n    value: function getLayer() {\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _canvas = this.getNativeCanvasElement();\n\n      Node.prototype.remove.call(this);\n\n      if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {\n        _canvas.parentNode.removeChild(_canvas);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getStage\",\n    value: function getStage() {\n      return this.parent;\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n      this.canvas.setSize(width, height);\n      this.hitCanvas.setSize(width, height);\n\n      this._setSmoothEnabled();\n\n      return this;\n    }\n  }, {\n    key: \"_validateAdd\",\n    value: function _validateAdd(child) {\n      var type = child.getType();\n\n      if (type !== 'Group' && type !== 'Shape') {\n        Util.throw('You may only add groups and shapes to a layer.');\n      }\n    }\n  }, {\n    key: \"_toKonvaCanvas\",\n    value: function _toKonvaCanvas(config) {\n      config = config || {};\n      config.width = config.width || this.getWidth();\n      config.height = config.height || this.getHeight();\n      config.x = config.x !== undefined ? config.x : this.x();\n      config.y = config.y !== undefined ? config.y : this.y();\n      return Node.prototype._toKonvaCanvas.call(this, config);\n    }\n  }, {\n    key: \"_checkVisibility\",\n    value: function _checkVisibility() {\n      var visible = this.visible();\n\n      if (visible) {\n        this.canvas._canvas.style.display = 'block';\n      } else {\n        this.canvas._canvas.style.display = 'none';\n      }\n    }\n  }, {\n    key: \"_setSmoothEnabled\",\n    value: function _setSmoothEnabled() {\n      this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      if (this.parent) {\n        return this.parent.width();\n      }\n    }\n  }, {\n    key: \"setWidth\",\n    value: function setWidth() {\n      Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      if (this.parent) {\n        return this.parent.height();\n      }\n    }\n  }, {\n    key: \"setHeight\",\n    value: function setHeight() {\n      Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\n    }\n  }, {\n    key: \"batchDraw\",\n    value: function batchDraw() {\n      var _this2 = this;\n\n      if (!this._waitingForDraw) {\n        this._waitingForDraw = true;\n        Util.requestAnimFrame(function () {\n          _this2.draw();\n\n          _this2._waitingForDraw = false;\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(pos) {\n      if (!this.isListening() || !this.isVisible()) {\n        return null;\n      }\n\n      var spiralSearchDistance = 1;\n      var continueSearch = false;\n\n      while (true) {\n        for (var i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\n          var intersectionOffset = INTERSECTION_OFFSETS[i];\n\n          var obj = this._getIntersection({\n            x: pos.x + intersectionOffset.x * spiralSearchDistance,\n            y: pos.y + intersectionOffset.y * spiralSearchDistance\n          });\n\n          var shape = obj.shape;\n\n          if (shape) {\n            return shape;\n          }\n\n          continueSearch = !!obj.antialiased;\n\n          if (!obj.antialiased) {\n            break;\n          }\n        }\n\n        if (continueSearch) {\n          spiralSearchDistance += 1;\n        } else {\n          return null;\n        }\n      }\n    }\n  }, {\n    key: \"_getIntersection\",\n    value: function _getIntersection(pos) {\n      var ratio = this.hitCanvas.pixelRatio;\n      var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;\n      var p3 = p[3];\n\n      if (p3 === 255) {\n        var colorKey = Util._rgbToHex(p[0], p[1], p[2]);\n\n        var shape = shapes[HASH + colorKey];\n\n        if (shape) {\n          return {\n            shape: shape\n          };\n        }\n\n        return {\n          antialiased: true\n        };\n      } else if (p3 > 0) {\n        return {\n          antialiased: true\n        };\n      }\n\n      return {};\n    }\n  }, {\n    key: \"drawScene\",\n    value: function drawScene(can, top) {\n      var layer = this.getLayer(),\n          canvas = can || layer && layer.getCanvas();\n\n      this._fire(BEFORE_DRAW, {\n        node: this\n      });\n\n      if (this.clearBeforeDraw()) {\n        canvas.getContext().clear();\n      }\n\n      Container.prototype.drawScene.call(this, canvas, top);\n\n      this._fire(DRAW, {\n        node: this\n      });\n\n      return this;\n    }\n  }, {\n    key: \"drawHit\",\n    value: function drawHit(can, top) {\n      var layer = this.getLayer(),\n          canvas = can || layer && layer.hitCanvas;\n\n      if (layer && layer.clearBeforeDraw()) {\n        layer.getHitCanvas().getContext().clear();\n      }\n\n      Container.prototype.drawHit.call(this, canvas, top);\n      return this;\n    }\n  }, {\n    key: \"enableHitGraph\",\n    value: function enableHitGraph() {\n      this.hitGraphEnabled(true);\n      return this;\n    }\n  }, {\n    key: \"disableHitGraph\",\n    value: function disableHitGraph() {\n      this.hitGraphEnabled(false);\n      return this;\n    }\n  }, {\n    key: \"setHitGraphEnabled\",\n    value: function setHitGraphEnabled(val) {\n      Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n      this.listening(val);\n    }\n  }, {\n    key: \"getHitGraphEnabled\",\n    value: function getHitGraphEnabled(val) {\n      Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n      return this.listening();\n    }\n  }, {\n    key: \"toggleHitCanvas\",\n    value: function toggleHitCanvas() {\n      if (!this.parent || !this.parent['content']) {\n        return;\n      }\n\n      var parent = this.parent;\n      var added = !!this.hitCanvas._canvas.parentNode;\n\n      if (added) {\n        parent.content.removeChild(this.hitCanvas._canvas);\n      } else {\n        parent.content.appendChild(this.hitCanvas._canvas);\n      }\n    }\n  }]);\n\n  return Layer;\n}(Container);\nLayer.prototype.nodeType = 'Layer';\n\n_registerNode(Layer);\n\nFactory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);\nFactory.addGetterSetter(Layer, 'clearBeforeDraw', true);\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());","map":null,"metadata":{},"sourceType":"module"}