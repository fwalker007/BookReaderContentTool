{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, n = 1, i = arguments.length; n < i; n++) {\n      for (var a in t = arguments[n]) {\n        Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);\n      }\n    }\n\n    return e;\n  }).apply(this, arguments);\n},\n    __importDefault = this && this.__importDefault || function (e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.useSnap = void 0;\n\nvar react_1 = __importDefault(require(\"react\")),\n    konva_1 = __importDefault(require(\"konva\")),\n    math_1 = require(\"../utils/math\"),\n    GUIDELINE_OFFSET = 5;\n\nfunction getObjectSnappingEdges(e) {\n  var t = e.__getNodeRect(),\n      n = math_1.getClientRect(__assign(__assign({}, t), {\n    rotation: konva_1.default.Util.radToDeg(t.rotation)\n  })),\n      i = e.getAbsolutePosition();\n\n  return {\n    vertical: [{\n      guide: n.x,\n      offset: i.x - n.x,\n      snap: \"start\"\n    }, {\n      guide: n.x + n.width / 2,\n      offset: i.x - n.x - n.width / 2,\n      snap: \"center\"\n    }, {\n      guide: n.x + n.width,\n      offset: i.x - n.x - n.width,\n      snap: \"end\"\n    }],\n    horizontal: [{\n      guide: n.y,\n      offset: i.y - n.y,\n      snap: \"start\"\n    }, {\n      guide: n.y + n.height / 2,\n      offset: i.y - n.y - n.height / 2,\n      snap: \"center\"\n    }, {\n      guide: n.y + n.height,\n      offset: i.y - n.y - n.height,\n      snap: \"end\"\n    }]\n  };\n}\n\nfunction getGuides(e, t) {\n  var n = [],\n      i = [];\n  e.vertical.forEach(function (e) {\n    t.vertical.forEach(function (t) {\n      var i = Math.abs(e - t.guide);\n      i < GUIDELINE_OFFSET && n.push({\n        lineGuide: e,\n        diff: i,\n        snap: t.snap,\n        offset: t.offset\n      });\n    });\n  }), e.horizontal.forEach(function (e) {\n    t.horizontal.forEach(function (t) {\n      var n = Math.abs(e - t.guide);\n      n < GUIDELINE_OFFSET && i.push({\n        lineGuide: e,\n        diff: n,\n        snap: t.snap,\n        offset: t.offset\n      });\n    });\n  });\n  var a = [],\n      r = n.sort(function (e, t) {\n    return e.diff - t.diff;\n  })[0],\n      o = i.sort(function (e, t) {\n    return e.diff - t.diff;\n  })[0];\n  return r && a.push(__assign({\n    orientation: \"V\"\n  }, r)), o && a.push(__assign(__assign({}, o), {\n    orientation: \"H\"\n  })), a;\n}\n\nfunction useSnap(e) {\n  var t = function t(e) {\n    return e.hasName(\"element\") || e.hasName(\"page-background\");\n  };\n\n  var n = function n(_n) {\n    _n.target.getLayer().find(\".guid-line\").forEach(function (e) {\n      return e.destroy();\n    });\n\n    var i,\n        a,\n        r,\n        o,\n        s,\n        u = getGuides((i = _n.target.nodes(), r = null === (a = e.current) || void 0 === a ? void 0 : a.getStage(), o = [], s = [], r.find(t).forEach(function (e) {\n      if (!(i.indexOf(e) >= 0)) {\n        var t = e.getClientRect({\n          skipShadow: !0,\n          skipStroke: !0\n        });\n        o.push(t.x, t.x + t.width, t.x + t.width / 2), s.push(t.y, t.y + t.height, t.y + t.height / 2);\n      }\n    }), {\n      vertical: o,\n      horizontal: s\n    }), getObjectSnappingEdges(_n.target));\n\n    if (u.length) {\n      !function (t) {\n        var n,\n            i = null === (n = e.current) || void 0 === n ? void 0 : n.getLayer();\n        t.forEach(function (e) {\n          if (\"H\" === e.orientation) {\n            var t = new konva_1.default.Line({\n              points: [-6e3, e.lineGuide, 6e3, e.lineGuide],\n              stroke: \"rgb(0, 161, 255)\",\n              strokeWidth: 1,\n              name: \"guid-line\",\n              dash: [4, 6]\n            });\n            i.add(t), i.batchDraw();\n          } else if (\"V\" === e.orientation) {\n            t = new konva_1.default.Line({\n              points: [e.lineGuide, -6e3, e.lineGuide, 6e3],\n              stroke: \"rgb(0, 161, 255)\",\n              strokeWidth: 1,\n              name: \"guid-line\",\n              dash: [4, 6]\n            });\n            i.add(t), i.batchDraw();\n          }\n        });\n      }(u);\n\n      var f = _n.target.getAbsolutePosition(),\n          d = __assign({}, f);\n\n      u.forEach(function (e) {\n        switch (e.snap) {\n          case \"start\":\n          case \"center\":\n          case \"end\":\n            switch (e.orientation) {\n              case \"V\":\n                d.x = e.lineGuide + e.offset;\n                break;\n\n              case \"H\":\n                d.y = e.lineGuide + e.offset;\n            }\n\n        }\n      });\n      var c = d.x - f.x,\n          h = d.y - f.y;\n\n      _n.target.nodes().forEach(function (e) {\n        var t = e.getAbsolutePosition();\n        e.setAbsolutePosition({\n          x: t.x + c,\n          y: t.y + h\n        });\n      });\n    }\n  },\n      i = function i(e) {\n    var t = e.target.getLayer();\n    t.find(\".guid-line\").forEach(function (e) {\n      return e.destroy();\n    }), t.batchDraw();\n  };\n\n  react_1.default.useEffect(function () {\n    e.current && (e.current.on(\"dragmove\", n), e.current.on(\"dragend\", i));\n  });\n}\n\nexports.useSnap = useSnap;","map":null,"metadata":{},"sourceType":"script"}