{"ast":null,"code":"import _inherits from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Development\\\\Encantos\\\\RandD\\\\Polotno\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Util } from './Util.js';\nimport { Konva } from './Global.js';\n\nfunction simplifyArray(arr) {\n  var retArr = [],\n      len = arr.length,\n      util = Util,\n      n,\n      val;\n\n  for (n = 0; n < len; n++) {\n    val = arr[n];\n\n    if (util._isNumber(val)) {\n      val = Math.round(val * 1000) / 1000;\n    } else if (!util._isString(val)) {\n      val = val + '';\n    }\n\n    retArr.push(val);\n  }\n\n  return retArr;\n}\n\nvar COMMA = ',',\n    OPEN_PAREN = '(',\n    CLOSE_PAREN = ')',\n    OPEN_PAREN_BRACKET = '([',\n    CLOSE_BRACKET_PAREN = '])',\n    SEMICOLON = ';',\n    DOUBLE_PAREN = '()',\n    EQUALS = '=',\n    CONTEXT_METHODS = ['arc', 'arcTo', 'beginPath', 'bezierCurveTo', 'clearRect', 'clip', 'closePath', 'createLinearGradient', 'createPattern', 'createRadialGradient', 'drawImage', 'ellipse', 'fill', 'fillText', 'getImageData', 'createImageData', 'lineTo', 'moveTo', 'putImageData', 'quadraticCurveTo', 'rect', 'restore', 'rotate', 'save', 'scale', 'setLineDash', 'setTransform', 'stroke', 'strokeText', 'transform', 'translate'];\nvar CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'lineCap', 'lineDashOffset', 'lineJoin', 'lineWidth', 'miterLimit', 'font', 'textAlign', 'textBaseline', 'globalAlpha', 'globalCompositeOperation', 'imageSmoothingEnabled'];\nvar traceArrMax = 100;\nexport var Context = /*#__PURE__*/function () {\n  function Context(canvas) {\n    _classCallCheck(this, Context);\n\n    this.canvas = canvas;\n    this._context = canvas._canvas.getContext('2d');\n\n    if (Konva.enableTrace) {\n      this.traceArr = [];\n\n      this._enableTrace();\n    }\n  }\n\n  _createClass(Context, [{\n    key: \"fillShape\",\n    value: function fillShape(shape) {\n      if (shape.fillEnabled()) {\n        this._fill(shape);\n      }\n    }\n  }, {\n    key: \"_fill\",\n    value: function _fill(shape) {}\n  }, {\n    key: \"strokeShape\",\n    value: function strokeShape(shape) {\n      if (shape.hasStroke()) {\n        this._stroke(shape);\n      }\n    }\n  }, {\n    key: \"_stroke\",\n    value: function _stroke(shape) {}\n  }, {\n    key: \"fillStrokeShape\",\n    value: function fillStrokeShape(shape) {\n      if (shape.attrs.fillAfterStrokeEnabled) {\n        this.strokeShape(shape);\n        this.fillShape(shape);\n      } else {\n        this.fillShape(shape);\n        this.strokeShape(shape);\n      }\n    }\n  }, {\n    key: \"getTrace\",\n    value: function getTrace(relaxed, rounded) {\n      var traceArr = this.traceArr,\n          len = traceArr.length,\n          str = '',\n          n,\n          trace,\n          method,\n          args;\n\n      for (n = 0; n < len; n++) {\n        trace = traceArr[n];\n        method = trace.method;\n\n        if (method) {\n          args = trace.args;\n          str += method;\n\n          if (relaxed) {\n            str += DOUBLE_PAREN;\n          } else {\n            if (Util._isArray(args[0])) {\n              str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\n            } else {\n              if (rounded) {\n                args = args.map(function (a) {\n                  return typeof a === 'number' ? Math.floor(a) : a;\n                });\n              }\n\n              str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\n            }\n          }\n        } else {\n          str += trace.property;\n\n          if (!relaxed) {\n            str += EQUALS + trace.val;\n          }\n        }\n\n        str += SEMICOLON;\n      }\n\n      return str;\n    }\n  }, {\n    key: \"clearTrace\",\n    value: function clearTrace() {\n      this.traceArr = [];\n    }\n  }, {\n    key: \"_trace\",\n    value: function _trace(str) {\n      var traceArr = this.traceArr,\n          len;\n      traceArr.push(str);\n      len = traceArr.length;\n\n      if (len >= traceArrMax) {\n        traceArr.shift();\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var pixelRatio = this.getCanvas().getPixelRatio();\n      this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(bounds) {\n      var canvas = this.getCanvas();\n\n      if (bounds) {\n        this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\n      } else {\n        this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\n      }\n    }\n  }, {\n    key: \"_applyLineCap\",\n    value: function _applyLineCap(shape) {\n      var lineCap = shape.getLineCap();\n\n      if (lineCap) {\n        this.setAttr('lineCap', lineCap);\n      }\n    }\n  }, {\n    key: \"_applyOpacity\",\n    value: function _applyOpacity(shape) {\n      var absOpacity = shape.getAbsoluteOpacity();\n\n      if (absOpacity !== 1) {\n        this.setAttr('globalAlpha', absOpacity);\n      }\n    }\n  }, {\n    key: \"_applyLineJoin\",\n    value: function _applyLineJoin(shape) {\n      var lineJoin = shape.attrs.lineJoin;\n\n      if (lineJoin) {\n        this.setAttr('lineJoin', lineJoin);\n      }\n    }\n  }, {\n    key: \"setAttr\",\n    value: function setAttr(attr, val) {\n      this._context[attr] = val;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(a0, a1, a2, a3, a4, a5) {\n      this._context.arc(a0, a1, a2, a3, a4, a5);\n    }\n  }, {\n    key: \"arcTo\",\n    value: function arcTo(a0, a1, a2, a3, a4) {\n      this._context.arcTo(a0, a1, a2, a3, a4);\n    }\n  }, {\n    key: \"beginPath\",\n    value: function beginPath() {\n      this._context.beginPath();\n    }\n  }, {\n    key: \"bezierCurveTo\",\n    value: function bezierCurveTo(a0, a1, a2, a3, a4, a5) {\n      this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);\n    }\n  }, {\n    key: \"clearRect\",\n    value: function clearRect(a0, a1, a2, a3) {\n      this._context.clearRect(a0, a1, a2, a3);\n    }\n  }, {\n    key: \"clip\",\n    value: function clip() {\n      this._context.clip();\n    }\n  }, {\n    key: \"closePath\",\n    value: function closePath() {\n      this._context.closePath();\n    }\n  }, {\n    key: \"createImageData\",\n    value: function createImageData(a0, a1) {\n      var a = arguments;\n\n      if (a.length === 2) {\n        return this._context.createImageData(a0, a1);\n      } else if (a.length === 1) {\n        return this._context.createImageData(a0);\n      }\n    }\n  }, {\n    key: \"createLinearGradient\",\n    value: function createLinearGradient(a0, a1, a2, a3) {\n      return this._context.createLinearGradient(a0, a1, a2, a3);\n    }\n  }, {\n    key: \"createPattern\",\n    value: function createPattern(a0, a1) {\n      return this._context.createPattern(a0, a1);\n    }\n  }, {\n    key: \"createRadialGradient\",\n    value: function createRadialGradient(a0, a1, a2, a3, a4, a5) {\n      return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);\n    }\n  }, {\n    key: \"drawImage\",\n    value: function drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n      var a = arguments,\n          _context = this._context;\n\n      if (a.length === 3) {\n        _context.drawImage(a0, a1, a2);\n      } else if (a.length === 5) {\n        _context.drawImage(a0, a1, a2, a3, a4);\n      } else if (a.length === 9) {\n        _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n      }\n    }\n  }, {\n    key: \"ellipse\",\n    value: function ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {\n      this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n  }, {\n    key: \"isPointInPath\",\n    value: function isPointInPath(x, y) {\n      return this._context.isPointInPath(x, y);\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(path2d) {\n      if (path2d) {\n        this._context.fill(path2d);\n      } else {\n        this._context.fill();\n      }\n    }\n  }, {\n    key: \"fillRect\",\n    value: function fillRect(x, y, width, height) {\n      this._context.fillRect(x, y, width, height);\n    }\n  }, {\n    key: \"strokeRect\",\n    value: function strokeRect(x, y, width, height) {\n      this._context.strokeRect(x, y, width, height);\n    }\n  }, {\n    key: \"fillText\",\n    value: function fillText(text, x, y, maxWidth) {\n      if (maxWidth) {\n        this._context.fillText(text, x, y, maxWidth);\n      } else {\n        this._context.fillText(text, x, y);\n      }\n    }\n  }, {\n    key: \"measureText\",\n    value: function measureText(text) {\n      return this._context.measureText(text);\n    }\n  }, {\n    key: \"getImageData\",\n    value: function getImageData(a0, a1, a2, a3) {\n      return this._context.getImageData(a0, a1, a2, a3);\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(a0, a1) {\n      this._context.lineTo(a0, a1);\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(a0, a1) {\n      this._context.moveTo(a0, a1);\n    }\n  }, {\n    key: \"rect\",\n    value: function rect(a0, a1, a2, a3) {\n      this._context.rect(a0, a1, a2, a3);\n    }\n  }, {\n    key: \"putImageData\",\n    value: function putImageData(a0, a1, a2) {\n      this._context.putImageData(a0, a1, a2);\n    }\n  }, {\n    key: \"quadraticCurveTo\",\n    value: function quadraticCurveTo(a0, a1, a2, a3) {\n      this._context.quadraticCurveTo(a0, a1, a2, a3);\n    }\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      this._context.restore();\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(a0) {\n      this._context.rotate(a0);\n    }\n  }, {\n    key: \"save\",\n    value: function save() {\n      this._context.save();\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a0, a1) {\n      this._context.scale(a0, a1);\n    }\n  }, {\n    key: \"setLineDash\",\n    value: function setLineDash(a0) {\n      if (this._context.setLineDash) {\n        this._context.setLineDash(a0);\n      } else if ('mozDash' in this._context) {\n        this._context['mozDash'] = a0;\n      } else if ('webkitLineDash' in this._context) {\n        this._context['webkitLineDash'] = a0;\n      }\n    }\n  }, {\n    key: \"getLineDash\",\n    value: function getLineDash() {\n      return this._context.getLineDash();\n    }\n  }, {\n    key: \"setTransform\",\n    value: function setTransform(a0, a1, a2, a3, a4, a5) {\n      this._context.setTransform(a0, a1, a2, a3, a4, a5);\n    }\n  }, {\n    key: \"stroke\",\n    value: function stroke(path2d) {\n      if (path2d) {\n        this._context.stroke(path2d);\n      } else {\n        this._context.stroke();\n      }\n    }\n  }, {\n    key: \"strokeText\",\n    value: function strokeText(a0, a1, a2, a3) {\n      this._context.strokeText(a0, a1, a2, a3);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(a0, a1, a2, a3, a4, a5) {\n      this._context.transform(a0, a1, a2, a3, a4, a5);\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(a0, a1) {\n      this._context.translate(a0, a1);\n    }\n  }, {\n    key: \"_enableTrace\",\n    value: function _enableTrace() {\n      var that = this,\n          len = CONTEXT_METHODS.length,\n          origSetter = this.setAttr,\n          n,\n          args;\n\n      var func = function func(methodName) {\n        var origMethod = that[methodName],\n            ret;\n\n        that[methodName] = function () {\n          args = simplifyArray(Array.prototype.slice.call(arguments, 0));\n          ret = origMethod.apply(that, arguments);\n\n          that._trace({\n            method: methodName,\n            args: args\n          });\n\n          return ret;\n        };\n      };\n\n      for (n = 0; n < len; n++) {\n        func(CONTEXT_METHODS[n]);\n      }\n\n      that.setAttr = function () {\n        origSetter.apply(that, arguments);\n        var prop = arguments[0];\n        var val = arguments[1];\n\n        if (prop === 'shadowOffsetX' || prop === 'shadowOffsetY' || prop === 'shadowBlur') {\n          val = val / this.canvas.getPixelRatio();\n        }\n\n        that._trace({\n          property: prop,\n          val: val\n        });\n      };\n    }\n  }, {\n    key: \"_applyGlobalCompositeOperation\",\n    value: function _applyGlobalCompositeOperation(node) {\n      var op = node.attrs.globalCompositeOperation;\n      var def = !op || op === 'source-over';\n\n      if (!def) {\n        this.setAttr('globalCompositeOperation', op);\n      }\n    }\n  }]);\n\n  return Context;\n}();\nCONTEXT_PROPERTIES.forEach(function (prop) {\n  Object.defineProperty(Context.prototype, prop, {\n    get: function get() {\n      return this._context[prop];\n    },\n    set: function set(val) {\n      this._context[prop] = val;\n    }\n  });\n});\nexport var SceneContext = /*#__PURE__*/function (_Context) {\n  _inherits(SceneContext, _Context);\n\n  var _super = _createSuper(SceneContext);\n\n  function SceneContext() {\n    _classCallCheck(this, SceneContext);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SceneContext, [{\n    key: \"_fillColor\",\n    value: function _fillColor(shape) {\n      var fill = shape.fill();\n      this.setAttr('fillStyle', fill);\n\n      shape._fillFunc(this);\n    }\n  }, {\n    key: \"_fillPattern\",\n    value: function _fillPattern(shape) {\n      this.setAttr('fillStyle', shape._getFillPattern());\n\n      shape._fillFunc(this);\n    }\n  }, {\n    key: \"_fillLinearGradient\",\n    value: function _fillLinearGradient(shape) {\n      var grd = shape._getLinearGradient();\n\n      if (grd) {\n        this.setAttr('fillStyle', grd);\n\n        shape._fillFunc(this);\n      }\n    }\n  }, {\n    key: \"_fillRadialGradient\",\n    value: function _fillRadialGradient(shape) {\n      var grd = shape._getRadialGradient();\n\n      if (grd) {\n        this.setAttr('fillStyle', grd);\n\n        shape._fillFunc(this);\n      }\n    }\n  }, {\n    key: \"_fill\",\n    value: function _fill(shape) {\n      var hasColor = shape.fill(),\n          fillPriority = shape.getFillPriority();\n\n      if (hasColor && fillPriority === 'color') {\n        this._fillColor(shape);\n\n        return;\n      }\n\n      var hasPattern = shape.getFillPatternImage();\n\n      if (hasPattern && fillPriority === 'pattern') {\n        this._fillPattern(shape);\n\n        return;\n      }\n\n      var hasLinearGradient = shape.getFillLinearGradientColorStops();\n\n      if (hasLinearGradient && fillPriority === 'linear-gradient') {\n        this._fillLinearGradient(shape);\n\n        return;\n      }\n\n      var hasRadialGradient = shape.getFillRadialGradientColorStops();\n\n      if (hasRadialGradient && fillPriority === 'radial-gradient') {\n        this._fillRadialGradient(shape);\n\n        return;\n      }\n\n      if (hasColor) {\n        this._fillColor(shape);\n      } else if (hasPattern) {\n        this._fillPattern(shape);\n      } else if (hasLinearGradient) {\n        this._fillLinearGradient(shape);\n      } else if (hasRadialGradient) {\n        this._fillRadialGradient(shape);\n      }\n    }\n  }, {\n    key: \"_strokeLinearGradient\",\n    value: function _strokeLinearGradient(shape) {\n      var start = shape.getStrokeLinearGradientStartPoint(),\n          end = shape.getStrokeLinearGradientEndPoint(),\n          colorStops = shape.getStrokeLinearGradientColorStops(),\n          grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\n\n      if (colorStops) {\n        for (var n = 0; n < colorStops.length; n += 2) {\n          grd.addColorStop(colorStops[n], colorStops[n + 1]);\n        }\n\n        this.setAttr('strokeStyle', grd);\n      }\n    }\n  }, {\n    key: \"_stroke\",\n    value: function _stroke(shape) {\n      var dash = shape.dash(),\n          strokeScaleEnabled = shape.getStrokeScaleEnabled();\n\n      if (shape.hasStroke()) {\n        if (!strokeScaleEnabled) {\n          this.save();\n          var pixelRatio = this.getCanvas().getPixelRatio();\n          this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        }\n\n        this._applyLineCap(shape);\n\n        if (dash && shape.dashEnabled()) {\n          this.setLineDash(dash);\n          this.setAttr('lineDashOffset', shape.dashOffset());\n        }\n\n        this.setAttr('lineWidth', shape.strokeWidth());\n\n        if (!shape.getShadowForStrokeEnabled()) {\n          this.setAttr('shadowColor', 'rgba(0,0,0,0)');\n        }\n\n        var hasLinearGradient = shape.getStrokeLinearGradientColorStops();\n\n        if (hasLinearGradient) {\n          this._strokeLinearGradient(shape);\n        } else {\n          this.setAttr('strokeStyle', shape.stroke());\n        }\n\n        shape._strokeFunc(this);\n\n        if (!strokeScaleEnabled) {\n          this.restore();\n        }\n      }\n    }\n  }, {\n    key: \"_applyShadow\",\n    value: function _applyShadow(shape) {\n      var _a, _b, _c;\n\n      var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black',\n          blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5,\n          offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\n        x: 0,\n        y: 0\n      },\n          scale = shape.getAbsoluteScale(),\n          ratio = this.canvas.getPixelRatio(),\n          scaleX = scale.x * ratio,\n          scaleY = scale.y * ratio;\n      this.setAttr('shadowColor', color);\n      this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\n      this.setAttr('shadowOffsetX', offset.x * scaleX);\n      this.setAttr('shadowOffsetY', offset.y * scaleY);\n    }\n  }]);\n\n  return SceneContext;\n}(Context);\nexport var HitContext = /*#__PURE__*/function (_Context2) {\n  _inherits(HitContext, _Context2);\n\n  var _super2 = _createSuper(HitContext);\n\n  function HitContext() {\n    _classCallCheck(this, HitContext);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(HitContext, [{\n    key: \"_fill\",\n    value: function _fill(shape) {\n      this.save();\n      this.setAttr('fillStyle', shape.colorKey);\n\n      shape._fillFuncHit(this);\n\n      this.restore();\n    }\n  }, {\n    key: \"strokeShape\",\n    value: function strokeShape(shape) {\n      if (shape.hasHitStroke()) {\n        this._stroke(shape);\n      }\n    }\n  }, {\n    key: \"_stroke\",\n    value: function _stroke(shape) {\n      if (shape.hasHitStroke()) {\n        var strokeScaleEnabled = shape.getStrokeScaleEnabled();\n\n        if (!strokeScaleEnabled) {\n          this.save();\n          var pixelRatio = this.getCanvas().getPixelRatio();\n          this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        }\n\n        this._applyLineCap(shape);\n\n        var hitStrokeWidth = shape.hitStrokeWidth();\n        var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\n        this.setAttr('lineWidth', strokeWidth);\n        this.setAttr('strokeStyle', shape.colorKey);\n\n        shape._strokeFuncHit(this);\n\n        if (!strokeScaleEnabled) {\n          this.restore();\n        }\n      }\n    }\n  }]);\n\n  return HitContext;\n}(Context);","map":null,"metadata":{},"sourceType":"module"}