{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (t, e, n, r) {\n  return new (n || (n = Promise))(function (o, a) {\n    function i(t) {\n      try {\n        u(r.next(t));\n      } catch (t) {\n        a(t);\n      }\n    }\n\n    function s(t) {\n      try {\n        u(r.throw(t));\n      } catch (t) {\n        a(t);\n      }\n    }\n\n    function u(t) {\n      var e;\n      t.done ? o(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) {\n        t(e);\n      })).then(i, s);\n    }\n\n    u((r = r.apply(t, e || [])).next());\n  });\n},\n    __generator = this && this.__generator || function (t, e) {\n  var n,\n      r,\n      o,\n      a,\n      i = {\n    label: 0,\n    sent: function sent() {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return a = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n    return this;\n  }), a;\n\n  function s(a) {\n    return function (s) {\n      return function (a) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; i;) {\n          try {\n            if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;\n\n            switch (r = 0, o && (a = [2 & a[0], o.value]), a[0]) {\n              case 0:\n              case 1:\n                o = a;\n                break;\n\n              case 4:\n                return i.label++, {\n                  value: a[1],\n                  done: !1\n                };\n\n              case 5:\n                i.label++, r = a[1], a = [0];\n                continue;\n\n              case 7:\n                a = i.ops.pop(), i.trys.pop();\n                continue;\n\n              default:\n                if (!(o = i.trys, (o = o.length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {\n                  i = 0;\n                  continue;\n                }\n\n                if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                  i.label = a[1];\n                  break;\n                }\n\n                if (6 === a[0] && i.label < o[1]) {\n                  i.label = o[1], o = a;\n                  break;\n                }\n\n                if (o && i.label < o[2]) {\n                  i.label = o[2], i.ops.push(a);\n                  break;\n                }\n\n                o[2] && i.ops.pop(), i.trys.pop();\n                continue;\n            }\n\n            a = e.call(t, i);\n          } catch (t) {\n            a = [6, t], r = 0;\n          } finally {\n            n = o = 0;\n          }\n        }\n\n        if (5 & a[0]) throw a[1];\n        return {\n          value: a[0] ? a[1] : void 0,\n          done: !0\n        };\n      }([a, s]);\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.UndoManager = void 0;\n\nvar mobx_state_tree_1 = require(\"mobx-state-tree\");\n\nexports.UndoManager = mobx_state_tree_1.types.model(\"UndoManager\", {\n  history: mobx_state_tree_1.types.array(mobx_state_tree_1.types.frozen()),\n  undoIdx: -1,\n  targetPath: \"\"\n}).views(function (t) {\n  return {\n    get canUndo() {\n      return t.undoIdx > 0;\n    },\n\n    get canRedo() {\n      return t.undoIdx < t.history.length - 1;\n    }\n\n  };\n}).actions(function (t) {\n  var e,\n      n,\n      r = !1,\n      o = null,\n      a = 0,\n      i = !1;\n\n  function s() {\n    var t = mobx_state_tree_1.getSnapshot(e);\n    return {\n      pages: t.pages,\n      width: t.width,\n      height: t.height\n    };\n  }\n\n  function u(t) {\n    mobx_state_tree_1.applySnapshot(e.pages, t.pages), e.setSize(t.width, t.height);\n  }\n\n  return {\n    startTransaction: function startTransaction() {\n      i = !0;\n    },\n    endTransaction: function endTransaction(t) {\n      i = !1, t || this.requestAddState(s());\n    },\n    ignore: function ignore(e) {\n      return __awaiter(this, void 0, void 0, function () {\n        var n;\n        return __generator(this, function (r) {\n          switch (r.label) {\n            case 0:\n              t.startTransaction(), r.label = 1;\n\n            case 1:\n              return r.trys.push([1, 3,, 4]), [4, e()];\n\n            case 2:\n              return r.sent(), [3, 4];\n\n            case 3:\n              return n = r.sent(), setTimeout(function () {\n                throw n;\n              }), [3, 4];\n\n            case 4:\n              return t.endTransaction(!0), a = 0, clearTimeout(a), [2];\n          }\n        });\n      });\n    },\n    transaction: function transaction(e) {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (n) {\n          switch (n.label) {\n            case 0:\n              return [4, t.ignore(e)];\n\n            case 1:\n              return n.sent(), this.addUndoState(), [2];\n          }\n        });\n      });\n    },\n    requestAddState: function requestAddState(t) {\n      var e = this;\n      o = t, a || i || (r ? r = !1 : a = setTimeout(function () {\n        a = 0, clearTimeout(a), i || e.addUndoState();\n      }, 100));\n    },\n    addUndoState: function addUndoState() {\n      if (r) r = !1;else {\n        var e = t.history[t.undoIdx];\n        JSON.stringify(e) !== JSON.stringify(o) && (t.history.splice(t.undoIdx + 1), t.history.push(o), t.undoIdx = t.history.length - 1);\n      }\n    },\n    afterCreate: function afterCreate() {\n      var r = this;\n      if (!(e = mobx_state_tree_1.resolvePath(t, \"..\"))) throw new Error(\"Failed to find target store for UndoManager. Please provide `targetPath` property, or a `targetStore` in the environment\");\n      n = mobx_state_tree_1.onSnapshot(e, function () {\n        return r.requestAddState(s());\n      }), 0 === t.history.length && this.requestAddState(s());\n    },\n    clear: function clear() {\n      clearTimeout(a), a = 0, t.history.splice(0, t.history.length), t.undoIdx = -1, t.addUndoState(s());\n    },\n    beforeDestroy: function beforeDestroy() {\n      n();\n    },\n    undo: function undo() {\n      a && this.addUndoState(), t.undoIdx--, r = !0, u(t.history[t.undoIdx]);\n    },\n    redo: function redo() {\n      a && this.addUndoState(), t.undoIdx++, r = !0, u(t.history[t.undoIdx]);\n    },\n    replaceState: function replaceState() {\n      t.history[t.undoIdx] = s();\n    }\n  };\n}), exports.default = exports.UndoManager;","map":null,"metadata":{},"sourceType":"script"}