{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { IconContext, DefaultContext } from './iconContext';\n\nfunction Tree2Element(tree) {\n  return tree && tree.map(function (node, i) {\n    return React.createElement(node.tag, __assign({\n      key: i\n    }, node.attr), Tree2Element(node.child));\n  });\n  return tree && tree.map(function (node, i) {\n    return React.createElement(node.tag, __assign({\n      key: i\n    }, node.attr), node.content, Tree2Element(node.child));\n  });\n}\n\nfunction HasStrokes(svg) {\n  for (var prop in svg) {\n    if (prop[0] === '_') {\n      continue; // don't go into any \"private\" properties\n    }\n\n    if (prop === \"stroke\") {\n      return true;\n    } else if (typeof svg[prop] === \"object\") {\n      var result = HasStrokes(svg[prop]);\n\n      if (result) {\n        return result;\n      }\n    } else if (prop === \"content\") {\n      // check if this content is for the <style> tag\n      if (svg[\"tag\"] === \"style\") {\n        // \"content\" may have styles for the stroke\n        if (svg[prop].includes(\"stroke:\")) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function GenIcon(data) {\n  return function (props) {\n    return React.createElement(IconBase, __assign({\n      attr: __assign({}, data.attr)\n    }, props, {\n      hasStrokes: HasStrokes(data)\n    }), Tree2Element(data.child));\n  };\n}\nexport function IconBase(props) {\n  var elem = function elem(conf) {\n    var computedSize = props.size || conf.size || \"1em\";\n    var className;\n    if (conf.className) className = conf.className;\n    if (props.className) className = (className ? className + ' ' : '') + props.className;\n\n    var attr = props.attr,\n        fill = props.fill,\n        title = props.title,\n        hasStrokes = props.hasStrokes,\n        svgProps = __rest(props, [\"attr\", \"fill\", \"title\", \"hasStrokes\"]); // If the icon has explicit \"stroke\" attribute, do NOT set zero stroke width\n\n\n    var stroke = hasStrokes ? null : {\n      strokeWidth: 0\n    };\n    return React.createElement(\"svg\", __assign({\n      stroke: \"currentColor\",\n      fill: fill\n    }, stroke, conf.attr, attr, svgProps, {\n      className: className,\n      style: __assign(__assign({\n        color: props.color || conf.color\n      }, conf.style), props.style),\n      height: computedSize,\n      width: computedSize,\n      xmlns: \"http://www.w3.org/2000/svg\"\n    }), title && React.createElement(\"title\", null, title), props.children);\n  };\n\n  return IconContext !== undefined ? React.createElement(IconContext.Consumer, null, function (conf) {\n    return elem(conf);\n  }) : elem(DefaultContext);\n}","map":null,"metadata":{},"sourceType":"module"}